

-- preprocessed script file generated by lua-pystiller
-- used for MarKsCube/MarXsCube or Urd AI.
-- compile this with luac or bin2c.

-- MarKsCube/MarXsCube, Urd and lua-pystiller is by secondatke. 

__DEFINED = __DEFINED or {
  __get = function(id)
    assert(id, "__DEFINED.__get() failed. invalid id:"..tostring(id))
    assert(__DEFINED and __DEFINED[id], "__DEFINED.__get() failed. missing module:"..tostring(id))
    return __DEFINED[id]
  end
}


---------------------------------------



__DEFINED["lunacolort"] = (function()
lunacolort = { }

__available = False

if _URD_HOSTPLATFORM_ISPOSIX_ then __available = true end

__colors = { "BLACK", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE", "RESET" }

if __available then

__con = {
	BLACK  = string.char(0x1B) .. "[30m",
	RED  = string.char(0x1B) .. "[31m",
	GREEN = string.char(0x1B) .. "[32m",
	YELLOW = string.char(0x1B) .. "[33m",
	BLUE = string.char(0x1B) .. "[34m",
	MAGENTA = string.char(0x1B) .. "[35m",
	CYAN = string.char(0x1B) .. "[36m",
	WHITE = string.char(0x1B) .. "[37m",
	RESET = string.char(0x1B) .. "[0m",
}

else

__con = { }

for k, v in pairs(__colors) do __con[v] = "" end

end

lunacolort.c = __con
lunacolort.available = __available

return lunacolort
end)()


---------------------------------------



__DEFINED["object"] = (function()
object = { }

_object = { }

_object.new = function (self, t)
	r = t or { }
	setmetatable(r, self)
	self.__index = self
	return r
end

object.object = _object

return object
end)()


---------------------------------------



__DEFINED["ubtutil"] = (function()
ubtutil = { }

LCT = __DEFINED.__get 'lunacolort'

ubtutil.findin = function (t, func)
	for k, v in pairs(t) do
		if func(v) then return v end
	end
	return nil
end

ubtutil.cmpint = function (x, y)
	local x_, y_ = math.floor(x), math.floor(y)
	return x_ == y_
end

ubtutil.distance = function (pos0, pos1)
	return math.max(math.abs(pos0[1]-pos1[1]), math.abs(pos0[2]-pos1[2]))
end

ubtutil.map_debug_data = function(map)
		local r = LCT.c.RED .. 'Map Debug Data\n' .. LCT.c.RESET
		.. string.format('Map width: %d, height: %d\n', map.width, map.height)
		.. LCT.c.YELLOW .. 'Detailed data of cells:\n'  .. LCT.c.RESET
		for y = 0, map.height-1 do
			for x = 0, map.width-1 do
				local cell = map:getcell(x, y)
				local passable = cell:ispassable()
				local explored = cell:isexplored()
				if map:getcell(x, y):isonpath() then 		r = r .. string.format('%s ', passable and LCT.c.RED .. '■' .. LCT.c.RESET or '▲') 
				elseif map:getcell(x, y):isonsight() then 	r = r .. string.format('%s ', passable and LCT.c.WHITE .. '▣' .. LCT.c.RESET or LCT.c.CYAN .. '▓' .. LCT.c.RESET)
				elseif explored then 		r = r .. string.format('%s ', passable and LCT.c.GREEN .. '▢' .. LCT.c.RESET or LCT.c.BLUE .. '█' .. LCT.c.RESET)
				else 										r = r .. string.format('%s ', passable and LCT.c.YELLOW .. '□' .. LCT.c.RESET or LCT.c.YELLOW .. '▦' .. LCT.c.RESET) end
			end
			r = r .. '\n'
		end
		return r
	end

return ubtutil
end)()


---------------------------------------



__DEFINED["Environment"] = (function()
Environment = { }

print("_URD_HOSTTYPE_: " .. tostring(_URD_HOSTTYPE_))
print("_URD_HOSTPLATFORM_: " .. tostring(_URD_HOSTPLATFORM_))
print("_URD_HOSTPLATFORM_ISPOSIX_: " .. tostring(_URD_HOSTPLATFORM_ISPOSIX_))

if _URD_HOSTTYPE_ == 'LUATICPY' then

py = __DEFINED.__get ('python' .. '')

_pg = py.globals()
Environment.Exit = _pg.lua_break_test
Environment.Send = _pg.sock.send
Environment.Restart = _pg.lua_restart
Environment.SendTo = _pg.sock.sendto

elseif _URD_HOSTTYPE_ == 'LUABRIDG' then

Environment.Exit = Utility.Network.Urd.lua_break_test
Environment.Send = Utility.Network.Urd.socket_send
Environment.Restart = Utility.Network.Urd.lua_restart
Environment.SendTo = Utility.Network.Urd.socket_sendto

else

print('Unknown host type!')

end

Environment.INST_INIT = "POL"
Environment.SELF_PORT = 31002	-- will be inited by host with main.init()
Environment.TEAMNAME = "FLYIT"

return Environment
end)()


---------------------------------------



__DEFINED["session"] = (function()
session = { }

object = __DEFINED.__get 'object'
Util = __DEFINED.__get 'ubtutil'
LCT = __DEFINED.__get 'lunacolort'

Entity = object.object:new({

	id = 0,

	pos = { 0, 0 },

	mov_id = 'D',

	found = false,

	move = function (self, dir) self.mov_id = dir end,

	getpos = function (self) return self.pos end,

	setpos = function (self, x, y) self.pos = { x, y } end,

	getobjtype = function (self) return 'undefined' end,

	getcell = function (self, _mapobj) return _mapobj:getcell(unpack(self.pos)) end,

	debug_data = function (self) return string.format('Entity: %s, id=%d, x=%d, y=%d\n', self:getobjtype(), self.id, unpack(self.pos)) end
	})

PoliceObject = Entity:new({

	getobjtype = function (self) return 'POL' end,

	})

ThiefObject = Entity:new({

	getobjtype = function (self) return 'THI' end,

	})

session.PoliceObject, session.ThiefObject = PoliceObject, ThiefObject

session.SessionObject = object.object:new({

	map_obj = nil,

	num_pol = 0,

	num_thi = 0,

	sight_pol = 0,

	sight_thi = 0,

	polices = { },

	thives = { },

	before_update = function (self)
		Util.findin(self.polices, function (o) o.mov_id = 'T' end)
		Util.findin(self.thives, function (o) o.mov_id = 'T' end)
		self.map_obj:clear_on_sight()
		self.map_obj:clear_on_path()
	end,

	init_entities = function (self, num_pol, num_thi, type_self)
		self.polices, self.thives = { }, { }
		self.num_pol, self.num_thi = num_pol, num_thi

		for i = 1, num_pol do
			local t = PoliceObject:new()
			t.id = i-1
			table.insert(self.polices, t)
		end
		for i = 1, num_thi do 
			local t = ThiefObject:new()
			t.id = i-1
			table.insert(self.thives, t)
		end
	end,

	debug_data = function (self)
		local r = LCT.c.RED .. 'Session Debug Data\n' .. LCT.c.RESET
		if self.map_obj ~= nil then r = r .. string.format('Map width: %d, height: %d\n', self.map_obj.width, self.map_obj.height)
		else r = r .. "Map data not inited.\n" end
		r = r .. string.format('Num of polices: %d, thives: %d\n', self.num_pol, self.num_thi)
		.. string.format('Sight of polices: %d, thives: %d\n', self.sight_pol, self.sight_thi)
		.. LCT.c.YELLOW .. 'Detailed data of entities:\n' .. LCT.c.RESET

		Util.findin(self.polices, function (o) r = r .. o:debug_data() end)
		Util.findin(self.thives, function (o) r = r .. o:debug_data() end)
		return r
	end,

	pass_mov = function (self, ntick, type_self)
		local entities = nil
		if type_self == 'POL' then entities = self.polices else entities = self.thives end
		local t = ''
		Util.findin(entities, function (o) t = t .. string.format('%d,%s;', o.id, o.mov_id) end)

		return string.format('MOV[%d](%s)', ntick, t)
	end

	})

return session
end)()


---------------------------------------



__DEFINED["directions"] = (function()
directions = { }

Directions = {
	Up = 'B',
	Down = 'N',
	Left = 'X',
	Right = 'D',
	Still = 'T',
	Unknown = "blablabla",
}

directions.Directions = Directions

function directions.get_direction(pos1, pos2)
	if pos1.x == pos2.x then
		if pos1.y == pos2.y then
			do return Directions.Still end
		elseif pos1.y > pos2.y then
			do return Directions.Up end
		elseif pos1.y < pos2.y then
			do return Directions.Down end
		end
	elseif pos1.x > pos2.x then
		if pos1.y == pos2.y then
			do return Directions.Left end
		elseif pos1.y > pos2.y then
			do return Directions.Unknown end
		elseif pos1.y < pos2.y then
			do return Directions.Unknown end
		end
	elseif pos1.x < pos2.x then
		if pos1.y == pos2.y then
			do return Directions.Right end
		elseif pos1.y > pos2.y then
			do return Directions.Unknown end
		elseif pos1.y < pos2.y then
			do return Directions.Unknown end
		end
	end
end

return directions
end)()


---------------------------------------


Env = __DEFINED.__get 'Environment'
Session = __DEFINED.__get 'session'
Util = __DEFINED.__get 'ubtutil'

directions = __DEFINED.__get 'directions'

session_current = nil

function we_are_police()
	return Env.INST_INIT == 'POL' end

lbobject = { }

lbobject.new = function (self, t)
	r = t or { }
	setmetatable(r, self)
	self.__index = self
	return r
end

bt = { }

bt.func_empty = function(self, args) end

bt.state = { SUCCESS = 0, RUNNING = 1, FAILURE = 2, UNKNOWN = 3 }

btnode = lbobject:new({
		init = function (self, args)
			self:init_user(args) end,
		foo_end = function (self, args)
			self:foo_end(args) end,

		init_user = bt.func_empty,
		foo_end_user = bt.func_empty,

		execute = bt.func_empty,
	})

btnode_create_coroutine = function(co_foo)
	if co_foo == nil then co_foo = bt.func_empty end

	local node = btnode_coroutine:new()
	node.co_execute = co_foo
	return node
end

btnode_coroutine = btnode:new({
		_coroutine = nil,

		co_execute = bt.func_empty,
		co_init = bt.func_empty,

		init = function(self, args)
			self._coroutine = coroutine.create(self.co_execute)
			self:co_init(args)
			self:init_user(args)
		end,

		execute = function(self, args)
			local succeed, ret = coroutine.resume(self._coroutine, self, args)
			return ret
		end,

		foo_end = function(self, args)
			self._coroutine = nil
			self._coroutine = coroutine.create(self.co_execute)
			self:foo_end_user(args)
		end,
	})

btnode_ctrl = btnode:new({
		children = { },
		add_child = function (self, child)
			if #(self.children) == 0 then self.children = { } end
			table.insert(self.children, child)
			return self
		end,

		init = function(self, args)
			for i, node in ipairs(self.children) do node:init(args) end
			self:init_user(args)
		end,

		foo_end = function (self, args)
			for i, node in ipairs(self.children) do node:foo_end(args) end
			self:foo_end_user(args)
		end,
	})

btnode_coroutine_ctrl = btnode_coroutine:new({
		children = { }, add_child = btnode_ctrl.add_child,

		init = function(self, args)
			for i, node in ipairs(self.children) do
				node:init(args)
			end
			btnode_coroutine.init(self, args)
		end,
	})

btnode_parallel = btnode_ctrl:new({
		statuses = { },

		init_user = function(self, args)
			for i, node in ipairs(self.children) do
				self.statuses[node] = bt.state.UNKNOWN
			end
		end,

		execute = function (self, args)
			for i, node in ipairs(self.children) do
				local status = node:execute(args)
				self.statuses[node] = status

				if status == bt.state.SUCCESS then
					self:foo_end()
					return bt.state.SUCCESS
				end
				if status == bt.state.FAILURE then
					self:foo_end()
					return bt.state.FAILURE
				end
			end
			return bt.state.RUNNING
		end,
	})

btnode_priority_selector = btnode_coroutine_ctrl:new({

		_get_first_available_node = function (self, args, start)
			local node_current = nil
			local node_i = nil
			local ret_status = nil

			for i, node in ipairs(self.children) do
				if (i >= start) then
					local status = node:execute(args)
					if status ~= bt.state.FAILURE then
						node_current = node
						node_i = i
						ret_status = status
						break
					end
				end
			end
			
			return node_i, node_current, ret_status
		end,

		co_execute = function (self, args)

			if #(self.children) == 0 then return bt.state.SUCCESS end
			local node_i = 0
			local node_current
			local beg_status
			node_i, node_current, beg_status = self:_get_first_available_node(args, 1)

			if node_current == nil then
				self:foo_end(args)
				return bt.state.FAILURE
			else coroutine.yield(beg_status)
			end

			while true do
				local status = node_current:execute(args)

				if status == bt.state.RUNNING then
					coroutine.yield(status)
				elseif status == bt.state.SUCCESS then
					self:foo_end(args)
					do return bt.state.SUCCESS end
				elseif status == bt.state.FAILURE then
					node_i, node_current, beg_status = self:_get_first_available_node(args, node_i+1)
					
					if node_current == nil then
						self:foo_end(args)
						return bt.state.FAILURE
					else coroutine.yield(beg_status)
					end
				end
			end

		end,
	})

btnode_create_priority = function () return btnode_priority_selector:new() end

btnode_sequential = btnode_coroutine_ctrl:new({

	co_execute = function (self, args)

		for i, node in ipairs(self.children) do 
			while true do
				local status = node:execute(args)
				print(status)

				if status == bt.state.SUCCESS then
					break
				elseif status == bt.state.FAILURE then
					return status
				end

				coroutine.yield(status)
			end
		end

		return bt.state.SUCCESS
	end,

	})

btnode_create_sequential = function () return btnode_sequential:new() end

btnode_condition = btnode:new({
	_condition = function(args) return true end,
	_check = true,

	execute = function (self, args)
		if self:_condition(args) == self._check then
			return bt.state.SUCCESS
		else
			return bt.state.FAILURE
		end
	end
})

btnode_create_condition = function (cond, check)
	if check == nil then check = true end
	local node = btnode_condition:new()

	node._condition = cond
	node._check = check

	return node
end

-- when executed
--		execute _cond_node
--		if SUCCEED, execute _node and return status
--		if FAILED, return _fail_ret(default SUCCESS)
btnode_dec_cond = btnode:new({
	_node = nil,
	_cond_node = nil,

	_fail_ret = bt.state.SUCCESS,

	init = function (self, args)
		self.foo_end = self._node.foo_end
		self.init = self._node.init
		self._node:init(args)
	end,

	execute = function (self, args)
		local cond = self._cond_node:execute(args)
		if cond == bt.state.SUCCESS then
			do return self._node:execute(args) end
		else return self._fail_ret end
	end
})

btnode_createdec_cond = function (dnode, cond, failret)
	if failret == nil then failret = btnode_dec_cond._fail_ret end

	local node = btnode_dec_cond:new()

	node._node, node._cond_node, node._fail_ret = dnode, cond, failret

	return node
end

function thief_found()
	print ("checking theif_found .. ", session_current.thives[1].found)
	return session_current.thives[1].found end

function get_theif_pos(id)
	if id == nil then id = 0 end
	return session_current.thives[id+1].pos
end

function find_search_pos(obj)
	local search_target_org = { session_current.map_obj.width-obj.pos[1]-1, session_current.map_obj.height-obj.pos[2]-1 }

	local xmin = session_current.sight_pol
	local ymin = session_current.sight_pol
	local xmax = session_current.map_obj.width - session_current.sight_pol
	local ymax = session_current.map_obj.height - session_current.sight_pol

	if search_target_org[1] < xmin then search_target_org[1] = xmin end
	if search_target_org[1] > xmax then search_target_org[1] = xmax end
	if search_target_org[2] < ymin then search_target_org[2] = ymin end
	if search_target_org[2] > ymax then search_target_org[2] = ymax end

	local _u = 1
	local _v = 1

	print("entering loop")
	for _ox = 0, session_current.map_obj.width/2 do
		for _oy = 0, session_current.map_obj.height/2 do
			local ox = _ox * _u
			local oy = _oy * _v

			local search_target = { search_target_org[1]+ox, search_target_org[2]+oy }

			if search_target[1] < 0 or search_target[1] > session_current.map_obj.width	or 
				search_target[2] < 0 or search_target[2] > session_current.map_obj.width then break end

			local cell = session_current.map_obj:getcell(table.unpack(search_target))
			local passable = cell:ispassable()

			if passable then return search_target end

			_v = _v * -1
		end
		_u = _u * -1
	end

end

function urdpol_init()
if we_are_police() then
	for i, char in ipairs(session_current.polices) do

		local node_search = btnode_create_coroutine(function (self, args)
			local obj = args.obj

			print("Searching for target...")

			local search_target = find_search_pos(obj)

			print("Search dest set: ", search_target[1], search_target[2])

			while true do
				local cache = Utility.Urd.Pathfinding.Pathfindingcache()
				Utility.Urd.Pathfinding.find_8(obj:getcell(session_current.map_obj), session_current.map_obj:getcell(table.unpack(search_target)), cache)
				if not cache:ended() then obj:move(directions.get_direction(cache:getCur():getpos(), cache:next():getpos())) end
				coroutine.yield(bt.state.RUNNING)
			end

			return bt.state.SUCCESS
		end)

		local node_catch = btnode_create_coroutine(function (self, args)
			local obj = args.obj

			print("entering catch mode...")

			while true do
				local target = get_theif_pos(0)
				local cache = Utility.Urd.Pathfinding.Pathfindingcache()
				Utility.Urd.Pathfinding.find_8(obj:getcell(session_current.map_obj), session_current.map_obj:getcell(table.unpack(target)), cache)
				if not cache:ended() then obj:move(directions.get_direction(cache:getCur():getpos(), cache:next():getpos())) end
				coroutine.yield(bt.state.RUNNING)
			end

			return bt.state.SUCCESS
		end)

		print("initing brain...")

	char.brain =
		btnode_create_sequential()
			:add_child(
				btnode_createdec_cond(node_search, btnode_create_condition(thief_found, false)))
			:add_child(
				node_catch)

		char.brain:init()
		char.brain_activated = true
	end
end
end

function urdpol_tick()
if we_are_police() then
	for i,char in ipairs(session_current.polices) do

		if char.brain_activated then
			print("exectuing brain...")
			local status = char.brain:execute({obj = char})
			if status ~= bt.state.RUNNING then
				char.brain_activated = false
			end
		end

	end
end
end

-- interface, called to connect to server
function init(port, init_inst, teamname)
	print("UltraBt: Initing...")

	Env.SELF_PORT = port and port or Env.SELF_PORT
	Env.INST_INIT = init_inst and init_inst or Env.INST_INIT
	Env.TEAMNAME = teamname and teamname or Env.TEAMNAME

	Env.Send(string.format("%s(%s, %d)", Env.INST_INIT, Env.TEAMNAME, Env.SELF_PORT))

	-- init dummy thief, for automatic testing
	if Env.INST_INIT == "POL" then Env.SendTo("URD", "localhost", 31001) end
end

-- interface, react to instructions
function inst_parser(inst)
	local _inst = inst
	local _inst_type = string.sub(_inst, 1, 3)
	local _inst_parse_switch = {
		END = inst_parser_end,
		INF = inst_parser_inf,
		INI = inst_parser_ini,
	}
	_inst_parse_switch[_inst_type](_inst)
end

-- parse instruction 'END': close session, back to terminal
function inst_parser_end(inst)
	-- print debug data
	print(session_current:debug_data())
	-- print(session_current.map_obj:debug_data())

	-- reset session
	session_current = nil
	Utility.Urd.Pathfinding.pf_dispose()

	-- restart
	Env.Exit()
	Env.Restart()
end

-- parse instruction 'INI': set basic attributes of entities, init map
function inst_parser_ini(inst)
	session_current = Session.SessionObject:new({ })
	print(session_current:debug_data())

	-- pattern matching to extract information
	local w, h = string.gmatch(inst, '%[(%d+),(%d+)%]')()
	local sp, st = string.gmatch(inst, '%<(%d+),(%d+)%>')()
	local np, nt = string.gmatch(inst, '%((%d+),(%d+)%)')()

	w, h, sp, st, np, nt = math.floor(tonumber(w)), math.floor(tonumber(h)), math.floor(tonumber(sp)), math.floor(tonumber(st)), math.floor(tonumber(np)), math.floor(tonumber(nt))

	-- set sights
	session_current.sight_pol, session_current.sight_thi = sp, st

	-- init entities
	session_current:init_entities(np, nt, Env.INST_INIT)
	local t = nil
	if Env.INST_INIT == 'POL' then t = session_current.polices else t = session_current.thives end
	local i = 1
	for id, x, y in string.gmatch(inst, '(%d+),(%d+),(%d+);') do
		id, x, y = math.floor(tonumber(id)), math.floor(tonumber(x)), math.floor(tonumber(y))
		t[i].id = id
		t[i]:setpos(x, y)
		i = i + 1
	end

	-- init map
	session_current.map_obj = Utility.Urd.MapClass() -- Map.MapClass:new()
	session_current.map_obj:initmap(w, h)
		-- changed in CPath
	Utility.Urd.Pathfinding.pf_init(session_current.map_obj)

	urdpol_init()

	-- print debug data
	print(session_current:debug_data())
		-- changed in CPath
	print(Util.map_debug_data(session_current.map_obj))
end

-- parse instruction 'INF'
function inst_parser_inf(inst)
	local _clock, _time = os.clock(), os.time()

	-- pattern matching to extract information
	local _f_blocks = string.gmatch(inst, '%([%d,;]*%)')
	local pos_pols = _f_blocks()
	local blocks = _f_blocks()
	local thi_blocks = string.gmatch(inst, '%<[%d,;]*%>')()

	-- update police location
	for id, x, y in string.gmatch(pos_pols, '(%d+),(%d+),(%d+);') do
		id, x, y = math.floor(tonumber(id)), math.floor(tonumber(x)), math.floor(tonumber(y))
		local police = Util.findin(session_current.polices, function (o) return o.id == id end)
		police:setpos(x, y)
		police.found = true
	end

	-- update thief location
	for id, x, y in string.gmatch(thi_blocks, '(%d+),(%d+),(%d+);') do
		id, x, y = math.floor(tonumber(id)), math.floor(tonumber(x)), math.floor(tonumber(y))
		local thief = Util.findin(session_current.thives, function (o) return o.id == id end)
		thief:setpos(x, y)
		thief.found = true
	end

	-- update terrain status
	for x, y in string.gmatch(blocks, '(%d+),(%d+);') do
		x, y = math.floor(tonumber(x)), math.floor(tonumber(y))
		-- changed in CPath
		local cell = session_current.map_obj:getcell(x, y)
		cell:setexplored(true)
		cell:setunpassable(true)
	end

	-- get number of ticks
	local ntick = string.gmatch(inst, '%[(%d+)%]')()

	session_current:before_update()

	entities = {  }
	if Env.INST_INIT == 'POL' then
		entities.set = session_current.polices
		entities.sight = session_current.sight_pol
	elseif Env.INST_INIT == 'THI' then
		entities.set = session_current.thives
		entities.sight = session_current.sight_thi
	end

	Util.findin(entities.set, function (o)
			-- changed in CPath
			session_current.map_obj:update_explored(Utility.CellStruct(o:getpos()[1], o:getpos()[2]), entities.sight)
			session_current.map_obj:update_onsight(Utility.CellStruct(o:getpos()[1], o:getpos()[2]), entities.sight)
		end)

	------------------------------------------------------------------------------------------------------------------------

	-- -- changed in CPath
	-- for k, v in ipairs(session_current.polices) do
	-- 	local cache = Utility.Urd.Pathfinding.Pathfindingcache()
	-- 	Utility.Urd.Pathfinding.find(v:getcell(session_current.map_obj), session_current.map_obj:getcell(6, 12), cache)
	-- 	if not cache:ended() then v:move(directions.get_direction(cache:getCur():getpos(), cache:next():getpos())) end
	-- end

	urdpol_tick()

	------------------------------------------------------------------------------------------------------------------------

	-- changed in CPath
	print(Util.map_debug_data(session_current.map_obj))


	-- send move instruction
	Env.Send(session_current:pass_mov(ntick, Env.INST_INIT))
end