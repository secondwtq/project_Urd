

-- preprocessed script file generated by lua-pystiller
-- used for MarKsCube/MarXsCube or Urd AI.
-- compile this with luac or bin2c.

-- MarKsCube/MarXsCube, Urd and lua-pystiller is by secondatke. 

__DEFINED = __DEFINED or {
  __get = function(id)
    assert(id, "__DEFINED.__get() failed. invalid id:"..tostring(id))
    assert(__DEFINED and __DEFINED[id], "__DEFINED.__get() failed. missing module:"..tostring(id))
    return __DEFINED[id]
  end
}


---------------------------------------



__DEFINED["lunacolort"] = (function()
lunacolort = { }

__available = False

if _URD_HOSTPLATFORM_ISPOSIX_ then __available = true end

__colors = { "BLACK", "RED", "GREEN", "YELLOW", "BLUE", "MAGENTA", "CYAN", "WHITE", "RESET" }

if __available then

__con = {
	BLACK  = string.char(0x1B) .. "[30m",
	RED  = string.char(0x1B) .. "[31m",
	GREEN = string.char(0x1B) .. "[32m",
	YELLOW = string.char(0x1B) .. "[33m",
	BLUE = string.char(0x1B) .. "[34m",
	MAGENTA = string.char(0x1B) .. "[35m",
	CYAN = string.char(0x1B) .. "[36m",
	WHITE = string.char(0x1B) .. "[37m",
	RESET = string.char(0x1B) .. "[0m",
}

else

__con = { }

for k, v in pairs(__colors) do __con[v] = "" end

end

lunacolort.c = __con
lunacolort.available = __available

return lunacolort
end)()


---------------------------------------



__DEFINED["object"] = (function()
object = { }

_object = { }

_object.new = function (self, t)
	r = t or { }
	setmetatable(r, self)
	self.__index = self
	return r
end

object.object = _object

return object
end)()


---------------------------------------



__DEFINED["ubtutil"] = (function()
ubtutil = { }

LCT = __DEFINED.__get 'lunacolort'

ubtutil.findin = function (t, func)
	for k, v in pairs(t) do
		if func(v) then return v end
	end
	return nil
end

ubtutil.cmpint = function (x, y)
	local x_, y_ = math.floor(x), math.floor(y)
	return x_ == y_
end

ubtutil.distance = function (pos0, pos1)
	return math.max(math.abs(pos0[1]-pos1[1]), math.abs(pos0[2]-pos1[2]))
end

ubtutil.map_debug_data = function(map)
		local r = LCT.c.RED .. 'Map Debug Data\n' .. LCT.c.RESET
		.. string.format('Map width: %d, height: %d\n', map.width, map.height)
		.. LCT.c.YELLOW .. 'Detailed data of cells:\n'  .. LCT.c.RESET
		for y = 0, map.height-1 do
			for x = 0, map.width-1 do
				local cell = map:getcell(x, y)
				local passable = cell:ispassable()
				local explored = cell:isexplored()
				if map:getcell(x, y):isonpath() then 		r = r .. string.format('%s ', passable and LCT.c.RED .. '■' .. LCT.c.RESET or '▲') 
				elseif map:getcell(x, y):isonsight() then 	r = r .. string.format('%s ', passable and LCT.c.WHITE .. '▣' .. LCT.c.RESET or LCT.c.CYAN .. '▓' .. LCT.c.RESET)
				elseif explored then 		r = r .. string.format('%s ', passable and LCT.c.GREEN .. '▢' .. LCT.c.RESET or LCT.c.BLUE .. '█' .. LCT.c.RESET)
				else 										r = r .. string.format('%s ', passable and LCT.c.YELLOW .. '□' .. LCT.c.RESET or LCT.c.YELLOW .. '▦' .. LCT.c.RESET) end
			end
			r = r .. '\n'
		end
		return r
	end

return ubtutil
end)()


---------------------------------------



__DEFINED["Environment"] = (function()
Environment = { }

print("_URD_HOSTTYPE_: " .. tostring(_URD_HOSTTYPE_))
print("_URD_HOSTPLATFORM_: " .. tostring(_URD_HOSTPLATFORM_))
print("_URD_HOSTPLATFORM_ISPOSIX_: " .. tostring(_URD_HOSTPLATFORM_ISPOSIX_))

if _URD_HOSTTYPE_ == 'LUATICPY' then

py = __DEFINED.__get ('python' .. '')

_pg = py.globals()
Environment.Exit = _pg.lua_break_test
Environment.Send = _pg.sock.send
Environment.Restart = _pg.lua_restart
Environment.SendTo = _pg.sock.sendto

elseif _URD_HOSTTYPE_ == 'LUABRIDG' then

Environment.Exit = Utility.Network.Urd.lua_break_test
Environment.Send = Utility.Network.Urd.socket_send
Environment.Restart = Utility.Network.Urd.lua_restart
Environment.SendTo = Utility.Network.Urd.socket_sendto

else

print('Unknown host type!')

end

Environment.INST_INIT = "POL"
Environment.SELF_PORT = 31002	-- will be inited by host with main.init()
Environment.TEAMNAME = "FLYIT"

return Environment
end)()


---------------------------------------



__DEFINED["session"] = (function()
session = { }

object = __DEFINED.__get 'object'
Util = __DEFINED.__get 'ubtutil'
LCT = __DEFINED.__get 'lunacolort'

Entity = object.object:new({

	id = 0,

	pos = { 0, 0 },

	mov_id = 'D',

	move = function (self, dir) self.mov_id = dir end,

	getpos = function (self) return self.pos end,

	setpos = function (self, x, y) self.pos = { x, y } end,

	getobjtype = function (self) return 'undefined' end,

	getcell = function (self, _mapobj) return _mapobj:getcell(unpack(self.pos)) end,

	debug_data = function (self) return string.format('Entity: %s, id=%d, x=%d, y=%d\n', self:getobjtype(), self.id, unpack(self.pos)) end
	})

PoliceObject = Entity:new({

	getobjtype = function (self) return 'POL' end,

	})

ThiefObject = Entity:new({

	getobjtype = function (self) return 'THI' end,

	})

session.PoliceObject, session.ThiefObject = PoliceObject, ThiefObject

session.SessionObject = object.object:new({

	map_obj = nil,

	num_pol = 0,

	num_thi = 0,

	sight_pol = 0,

	sight_thi = 0,

	polices = { },

	thives = { },

	before_update = function (self)
		Util.findin(self.polices, function (o) o.mov_id = 'T' end)
		Util.findin(self.thives, function (o) o.mov_id = 'T' end)
		self.map_obj:clear_on_sight()
		self.map_obj:clear_on_path()
	end,

	init_entities = function (self, num_pol, num_thi, type_self)
		self.polices, self.thives = { }, { }
		self.num_pol, self.num_thi = num_pol, num_thi

		for i = 1, num_pol do
			local t = PoliceObject:new()
			t.id = i-1
			table.insert(self.polices, t)
		end
		for i = 1, num_thi do 
			local t = ThiefObject:new()
			t.id = i-1
			table.insert(self.thives, t)
		end
	end,

	debug_data = function (self)
		local r = LCT.c.RED .. 'Session Debug Data\n' .. LCT.c.RESET
		if self.map_obj ~= nil then r = r .. string.format('Map width: %d, height: %d\n', self.map_obj.width, self.map_obj.height)
		else r = r .. "Map data not inited.\n" end
		r = r .. string.format('Num of polices: %d, thives: %d\n', self.num_pol, self.num_thi)
		.. string.format('Sight of polices: %d, thives: %d\n', self.sight_pol, self.sight_thi)
		.. LCT.c.YELLOW .. 'Detailed data of entities:\n' .. LCT.c.RESET

		Util.findin(self.polices, function (o) r = r .. o:debug_data() end)
		Util.findin(self.thives, function (o) r = r .. o:debug_data() end)
		return r
	end,

	pass_mov = function (self, ntick, type_self)
		local entities = nil
		if type_self == 'POL' then entities = self.polices else entities = self.thives end
		local t = ''
		Util.findin(entities, function (o) t = t .. string.format('%d,%s;', o.id, o.mov_id) end)

		return string.format('MOV[%d](%s)', ntick, t)
	end

	})

return session
end)()


---------------------------------------



__DEFINED["directions"] = (function()
directions = { }

Directions = {
	Up = 'B',
	Down = 'N',
	Left = 'X',
	Right = 'D',
	Still = 'T',
	Unknown = "blablabla",
}

directions.Directions = Directions

function directions.get_direction(pos1, pos2)
	if pos1.x == pos2.x then
		if pos1.y == pos2.y then
			do return Directions.Still end
		elseif pos1.y > pos2.y then
			do return Directions.Up end
		elseif pos1.y < pos2.y then
			do return Directions.Down end
		end
	elseif pos1.x > pos2.x then
		if pos1.y == pos2.y then
			do return Directions.Left end
		elseif pos1.y > pos2.y then
			do return Directions.Unknown end
		elseif pos1.y < pos2.y then
			do return Directions.Unknown end
		end
	elseif pos1.x < pos2.x then
		if pos1.y == pos2.y then
			do return Directions.Right end
		elseif pos1.y > pos2.y then
			do return Directions.Unknown end
		elseif pos1.y < pos2.y then
			do return Directions.Unknown end
		end
	end
end

return directions
end)()


---------------------------------------


Env = __DEFINED.__get 'Environment'
Session = __DEFINED.__get 'session'
Util = __DEFINED.__get 'ubtutil'

directions = __DEFINED.__get 'directions'

session_current = nil

-- interface, called to connect to server
function init(port, init_inst, teamname)
	print("UltraBt: Initing...")

	Env.SELF_PORT = port and port or Env.SELF_PORT
	Env.INST_INIT = init_inst and init_inst or Env.INST_INIT
	Env.TEAMNAME = teamname and teamname or Env.TEAMNAME

	Env.Send(string.format("%s(%s, %d)", Env.INST_INIT, Env.TEAMNAME, Env.SELF_PORT))

	-- init dummy thief, for automatic testing
	if Env.INST_INIT == "POL" then Env.SendTo("URD", "localhost", 31001) end
end

-- interface, react to instructions
function inst_parser(inst)
	local _inst = inst
	local _inst_type = string.sub(_inst, 1, 3)
	local _inst_parse_switch = {
		END = inst_parser_end,
		INF = inst_parser_inf,
		INI = inst_parser_ini,
	}
	_inst_parse_switch[_inst_type](_inst)
end

-- parse instruction 'END': close session, back to terminal
function inst_parser_end(inst)
	-- print debug data
	print(session_current:debug_data())
	-- print(session_current.map_obj:debug_data())

	-- reset session
	session_current = nil
	Utility.Urd.Pathfinding.pf_dispose()

	-- restart
	Env.Exit()
	Env.Restart()
end

-- parse instruction 'INI': set basic attributes of entities, init map
function inst_parser_ini(inst)
	session_current = Session.SessionObject:new({ })
	print(session_current:debug_data())

	-- pattern matching to extract information
	local w, h = string.gmatch(inst, '%[(%d+),(%d+)%]')()
	local sp, st = string.gmatch(inst, '%<(%d+),(%d+)%>')()
	local np, nt = string.gmatch(inst, '%((%d+),(%d+)%)')()

	w, h, sp, st, np, nt = math.floor(tonumber(w)), math.floor(tonumber(h)), math.floor(tonumber(sp)), math.floor(tonumber(st)), math.floor(tonumber(np)), math.floor(tonumber(nt))

	-- set sights
	session_current.sight_pol, session_current.sight_thi = sp, st

	-- init entities
	session_current:init_entities(np, nt, Env.INST_INIT)
	local t = nil
	if Env.INST_INIT == 'POL' then t = session_current.polices else t = session_current.thives end
	local i = 1
	for id, x, y in string.gmatch(inst, '(%d+),(%d+),(%d+);') do
		id, x, y = math.floor(tonumber(id)), math.floor(tonumber(x)), math.floor(tonumber(y))
		t[i].id = id
		t[i]:setpos(x, y)
		i = i + 1
	end

	-- init map
	session_current.map_obj = Utility.Urd.MapClass() -- Map.MapClass:new()
	session_current.map_obj:initmap(w, h)
		-- changed in CPath
	Utility.Urd.Pathfinding.pf_init(session_current.map_obj)

	-- print debug data
	print(session_current:debug_data())
		-- changed in CPath
	print(Util.map_debug_data(session_current.map_obj))
end

-- parse instruction 'INF'
function inst_parser_inf(inst)
	local _clock, _time = os.clock(), os.time()

	-- pattern matching to extract information
	local _f_blocks = string.gmatch(inst, '%([%d,;]*%)')
	local pos_pols = _f_blocks()
	local blocks = _f_blocks()

	-- update police location
	for id, x, y in string.gmatch(pos_pols, '(%d+),(%d+),(%d+);') do
		id, x, y = math.floor(tonumber(id)), math.floor(tonumber(x)), math.floor(tonumber(y))
		local police = Util.findin(session_current.polices, function (o) return o.id == id end)
		police:setpos(x, y)
	end
	-- update terrain status
	for x, y in string.gmatch(blocks, '(%d+),(%d+);') do
		x, y = math.floor(tonumber(x)), math.floor(tonumber(y))
		-- changed in CPath
		local cell = session_current.map_obj:getcell(x, y)
		cell:setexplored(true)
		cell:setunpassable(true)
	end

	-- get number of ticks
	local ntick = string.gmatch(inst, '%[(%d+)%]')()

	session_current:before_update()

	entities = {  }
	if Env.INST_INIT == 'POL' then
		entities.set = session_current.polices
		entities.sight = session_current.sight_pol
	elseif Env.INST_INIT == 'THI' then
		entities.set = session_current.thives
		entities.sight = session_current.sight_thi
	end

	Util.findin(entities.set, function (o)
			-- changed in CPath
			session_current.map_obj:update_explored(Utility.CellStruct(o:getpos()[1], o:getpos()[2]), entities.sight)
			session_current.map_obj:update_onsight(Utility.CellStruct(o:getpos()[1], o:getpos()[2]), entities.sight)
		end)

	-- changed in CPath
	for k, v in ipairs(session_current.polices) do
		local cache = Utility.Urd.Pathfinding.Pathfindingcache()
		Utility.Urd.Pathfinding.find(v:getcell(session_current.map_obj), session_current.map_obj:getcell(21, 21), cache)
		if not cache:ended() then v:move(directions.get_direction(cache:getCur():getpos(), cache:next():getpos())) end
	end

	-- changed in CPath
	print(Util.map_debug_data(session_current.map_obj))

	-- for k, v in ipairs(session_current.polices) do
	-- 	if Map.iscellpassable(session_current.map_obj:getneighborcell(v:getcell(session_current.map_obj), Directions.Up)) then v:move(Directions.Up)
	-- 	elseif Map.iscellpassable(session_current.map_obj:getneighborcell(v:getcell(session_current.map_obj), Directions.Down)) then v:move(Directions.Down)
	-- 	elseif Map.iscellpassable(session_current.map_obj:getneighborcell(v:getcell(session_current.map_obj), Directions.Left)) then v:move(Directions.Left)
	-- 	elseif Map.iscellpassable(session_current.map_obj:getneighborcell(v:getcell(session_current.map_obj), Directions.Right)) then v:move(Directions.Right)
	-- 	end
	-- end

	local _clock_, _time_ = os.clock(), os.time()
	print(_clock, _clock_, _clock_-_clock)
	print(_time, _time_, _time_-_time)

	-- send move instruction
	Env.Send(session_current:pass_mov(ntick, Env.INST_INIT))
end