"""
lua-pystiller by secondatke
	a python port(use tree instead of stack) of lua-distiller@github.com
	this utility is a part of MarKsCube/MarXsCube extras
	
	dependency: 
	
	 	* python27 basic runtime
	 	* python27 regex library
	 	* python 2.x __future__ print function
	 	* python27 argparse

changelog:
		initial version: 2014.08.25 EVE
"""

from __future__ import print_function
import sys
import os
import re

import argparse

COMMENT_MARK = '--'

HR = "\n\n---------------------------------------\n\n\n"

DISTILLER_HEAD = """

-- preprocessed script file generated by lua-pystiller
-- used for MarKsCube/MarXsCube or Urd AI.
-- compile this with luac or bin2c.

-- MarKsCube/MarXsCube, Urd and lua-pystiller is by secondatke. 

__DEFINED = __DEFINED or {
  __get = function(id)
    assert(id, "__DEFINED.__get() failed. invalid id:"..tostring(id))
    assert(__DEFINED and __DEFINED[id], "__DEFINED.__get() failed. missing module:"..tostring(id))
    return __DEFINED[id]
  end
}
""" + HR

EXTNAME = '.lua'

_argparser = argparse.ArgumentParser(prog='lua-pystiller', 
										description=sys.modules[__name__].__doc__,
										formatter_class=argparse.RawDescriptionHelpFormatter)
_argparser.add_argument('-i', nargs=1, dest='inputfile', help='define the input file.', required=True)
_argparser.add_argument('-o', nargs=1, dest='outputfile', help="define the output file.")

class dependency_node(object):

	def __init__(self, name, parent=None):
		self.name = name
		self.code = ""
		self.childs = [ ]
		self.level = 0
		self.parent = None

		if parent != None:
			self.level = parent.level+1
			self.parent = parent

	def __repr__(self):
		return "Node object, name: %(name)s, level: %(level)d" % (self.__dict__)

	def append_child(self, child):
		self.childs.append(child)
		child.parent = self

	def has_child_rec(self, child_name):
		if self.name == child_name:
			return True, self
		else:
			if len(self.childs) == 0:
				return False, None
			for child in self.childs:
				h, c = child.has_child_rec(child_name)
				if h == True:
					return h, c
			return False, None

	def remove_child(self, child_name):
		for child in self.childs:
			if child.name == child_name:
				self.childs.remove(child)
				child.parent = None
				return

	def get_child_at_level(self, child_level, include_self=False):
		ret = [ ]
		for child in self.childs:
			ret.extend(child.get_child_at_level(child_level, True))
		if include_self and self.level == child_level:
			ret.append(self)
		return ret

	def get_max_child_level(self):
		ret = self.level
		for child in self.childs:
			t = child.get_max_child_level()
			if t > ret:
				ret = t
		return ret

node_root = dependency_node("urdmain")

def search_requires(src_node):
	global node_root
	print ("\t\tsearching requires of %s ..." % src_node.name, file=sys.stderr)
	pat = re.compile(r"^.*require[( ]['\"]([a-zA-Z0-9._/-]+)['\"]")
	for line in src_node.code.splitlines():
		match = pat.search(line)
		if match != None:
			if (line.find(COMMENT_MARK) == -1) or (line.find(COMMENT_MARK) < line.find('require')):
				module_name = match.groups()[0]
				print ("module %s required by %s." % (module_name, src_node.name), file=sys.stderr)

				global node_root
				duped, dup_child = node_root.has_child_rec(module_name)

				if duped == False:
					node_child = dependency_node(module_name, src_node)
					with open(module_name+EXTNAME, 'r') as fp:
						node_child.code = fp.read()
					src_node.append_child(node_child)
					search_requires(node_child)
					node_child.code = node_child.code.replace('require', '__DEFINED.__get')
				else:
					if src_node.level+1 > dup_child.level:
						node_child.parent.remove_child(node_child.name)
						src_node.append_child(dup_child)

def gen_list(root):
	max_level = root.get_max_child_level()
	_ret = [root.get_child_at_level(i) for i in xrange(root.level, max_level+1)]
	ret = [ ]
	for level in xrange(max_level, root.level-1, -1):
		ret.extend(_ret[level])
	return ret

def distillify(node):
	ret = """
__DEFINED["%(name)s"] = (function()
%(code)s
end)()
""" % node.__dict__
	return ret

def main():
	args = _argparser.parse_args()

	input_filename = args.inputfile[0] # "urdmain.lua"
	output_filename = args.outputfile[0]

	input_modulename = os.path.splitext(input_filename)[0]
	global node_root
	node_root = dependency_node(input_modulename)
	with open(input_filename, 'r') as fp:
		node_root.code = fp.read()

	search_requires(node_root)
	node_root.code = node_root.code.replace('require', '__DEFINED.__get')

	ret = ""
	ret += DISTILLER_HEAD
	ret += HR.join(map(distillify, gen_list(node_root)))

	ret += HR

	ret += node_root.code

	if output_filename:
		with open(output_filename, 'w') as fp:
			fp.write(ret)
	else:
		print (ret)


if __name__ == '__main__':
	main()

